<!doctype html>
<html lang="th">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
		<title>‡πÄ‡∏Å‡∏°‡∏á‡∏πmango</title>

		<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;500;700&display=swap" rel="stylesheet" />

		<style>
			:root {
				--bg-dark: #121217;
				--panel-dark: #1e1f29;
				--accent: #7c5cff;
				--text-light: #e1e2e7;
				--text-muted: #888ba7;
				--btn-bg: #2a2c3d;
				--btn-hover: #3b3f58;
				--shadow: rgba(124, 92, 255, 0.4);
			}
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
				font-family: 'Poppins', sans-serif;
				-webkit-tap-highlight-color: transparent;
			}
			body {
				display: flex;
				justify-content: center;
				align-items: center;
				min-height: 100vh;
				background: var(--bg-dark);
				color: var(--text-light);
			}
			.game-container {
				text-align: center;
				background: var(--panel-dark);
				border-radius: 20px;
				padding: 25px 30px;
				box-shadow: 0 10px 30px var(--shadow);
				position: relative;
				z-index: 0;
			}
			.score {
				font-size: 22px;
				margin-bottom: 8px;
				color: var(--accent);
				font-weight: 700;
			}
			canvas {
				border: 3px solid var(--accent);
				border-radius: 10px;
				background: #2a2c3d;
				width: 100%;
				max-width: 400px;
				height: auto;
			}
			.controls {
				margin-top: 24px;
			}
			button {
				background: var(--btn-bg);
				color: var(--text-light);
				border: none;
				padding: 18px 24px;
				border-radius: 14px;
				font-size: 1.4rem;
				font-weight: 600;
				cursor: pointer;
				margin: 8px;
				transition:
					background 0.3s ease,
					box-shadow 0.3s ease,
					transform 0.15s ease;
				box-shadow: 0 4px 8px var(--shadow);
			}
			button:hover {
				background: var(--btn-hover);
				box-shadow: 0 6px 20px var(--shadow);
			}
			button:active {
				transform: scale(0.96);
			}
			.dpad {
				display: grid;
				grid-template-columns: 60px 60px 60px;
				grid-template-rows: 60px 60px 60px;
				justify-content: center;
				gap: 6px;
				margin-top: 16px;
			}
			.dpad button {
				width: 60px;
				height: 60px;
				font-size: 24px;
				border-radius: 12px;
				padding: 0;
			}
			.dpad .empty {
				visibility: hidden;
			}
			.game-over {
				display: none;
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				background: rgba(0, 0, 0, 0.85);
				padding: 30px;
				border-radius: 15px;
				text-align: center;
				z-index: 3000;
			}
			#leaderboard-ui {
    position: absolute;
    top: 12px;
    left: 12px;
    z-index: 20;
    background: #181828ee;
    border-radius: 12px;
    box-shadow: 0 2px 8px #0003;
    padding: 10px 16px 10px 16px;
    min-width: 120px;
    max-width: 220px;
    font-size: 0.98rem;
    color: #fff;
    opacity: 0.97;
    transition: opacity 0.2s;
  }
  #leaderboard-ui h4 {
    margin: 0 0 6px 0;
    font-size: 1.02em;
    color: #a78bfa;
    letter-spacing: 0.5px;
    text-align: left;
    font-weight: 600;
  }
  #leaderboard-ui table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.97em;
  }
  #leaderboard-ui th, #leaderboard-ui td {
    padding: 2px 4px;
    text-align: center;
  }
  #leaderboard-ui th {
    color: #a78bfa;
    font-weight: 500;
    font-size: 0.97em;
  }
  #leaderboard-ui tr:nth-child(even) td {
    background: #23243a44;
  }
			@media (max-width: 480px) {
				.dpad button {
					width: 50px;
					height: 50px;
					font-size: 20px;
				}
			}
		</style>
	</head>
	<body>
		<div class="game-container">
			<div class="score" style="display:flex;align-items:center;gap:0.5em;justify-content:center;">
				<span id="gameTime" style="font-size:16px;color:#fff;opacity:0.7;min-width:48px;text-align:right;">0.0s</span>
				<span style="flex-shrink:0;">‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: <span id="score">0</span></span>
			</div>
			<canvas id="gameCanvas" width="390" height="390"></canvas>
			<div class="controls">
				<button id="pauseBtn" style="background:#a78bfa;color:#222;min-width:44px;">‚è∏Ô∏è</button>
				<button onclick="startGame()">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà</button>
			</div>
			<div class="dpad">
				<div class="empty"></div>
				<button id="up">‚¨ÜÔ∏è</button>
				<div class="empty"></div>
				<button id="left">‚¨ÖÔ∏è</button>
				<div class="empty"></div>
				<button id="right">‚û°Ô∏è</button>
				<div class="empty"></div>
				<button id="down">‚¨áÔ∏è</button>
				<div class="empty"></div>
			</div>
			<div class="game-over" id="gameOver">
				<h2>‡∏à‡∏ö‡πÄ‡∏Å‡∏°!</h2>
				<p>‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì: <span id="finalScore">0</span></p>
				<p>‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤: <span id="finalTime">0.0</span> ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ</p>
				<button onclick="startGame()">‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</button>
			</div>
			<button id="settingsBtn" title="‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤" style="position:absolute;top:10px;right:10px;z-index:10;background:#222;color:#fff;border-radius:50%;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:1.5rem;box-shadow:0 2px 8px #7c5cff44;border:none;cursor:pointer;">
				<span>‚öôÔ∏è</span>
			</button>
			<div id="settingsModal" style="display:none;position:fixed;z-index:1000;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.25);backdrop-filter:blur(2.5px);justify-content:center;align-items:center;">
  <div style="background:#23243a;padding:24px 4vw 20px 4vw;border-radius:18px;box-shadow:0 8px 32px #000a;min-width:0;max-width:99vw;width:100%;max-width:400px;position:relative;display:flex;flex-direction:column;align-items:center;">
    <button id="closeSettings" style="position:absolute;top:12px;right:12px;background:none;border:none;color:#fff;font-size:1.5rem;cursor:pointer;">‚úñÔ∏è</button>
    <h3 style="color:#a78bfa;margin-bottom:20px;font-size:1.22rem;font-weight:600;letter-spacing:0.5px;text-align:center;width:100%;">‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏Å‡∏°</h3>
    <div style="display:flex;flex-direction:column;gap:18px;width:100%;max-width:340px;margin:0 auto;">
      <div style="display:flex;align-items:center;justify-content:space-between;width:100%;gap:12px;background:#181828;border-radius:14px;padding:14px 12px;box-sizing:border-box;flex-wrap:wrap;">
        <span style="color:#fff;font-size:1.12rem;min-width:80px;text-align:left;">‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß</span>
        <input id="speedInput" type="number" min="200" max="500" value="200" step="10" style="width:60px;font-size:1.12rem;text-align:center;box-sizing:border-box;background:#23243a;border:none;color:#fff;border-radius:8px;padding:4px 8px;">
      </div>
      <div style="display:flex;align-items:center;justify-content:space-between;width:100%;gap:12px;background:#181828;border-radius:14px;padding:14px 12px;box-sizing:border-box;flex-wrap:wrap;">
        <span style="color:#fff;font-size:1.12rem;min-width:80px;text-align:left;">‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ú‡∏•‡πÑ‡∏°‡πâ</span>
        <input id="foodInput" type="number" min="3" max="10" value="3" style="width:60px;font-size:1.12rem;text-align:center;box-sizing:border-box;background:#23243a;border:none;color:#fff;border-radius:8px;padding:4px 8px;">
      </div>
    </div>
  </div>
</div>
			<table id="leaderboard" style="width:100%;max-width:350px;margin:18px auto 0 auto;background:#181828;border-radius:12px;box-shadow:0 2px 8px #0002;font-size:1rem;display:none;">
  <thead>
    <tr style="color:#a78bfa;text-align:center;">
      <th style="padding:7px 0;">#</th>
      <th style="padding:7px 0;">‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô</th>
      <th style="padding:7px 0;">‡πÄ‡∏ß‡∏•‡∏≤ (s)</th>
    </tr>
  </thead>
  <tbody id="leaderboardBody"></tbody>
</table>
<button id="leaderboardBtn" title="‡∏î‡∏π‡∏≠‡∏±‡∏ô‡∏î‡∏±‡∏ö" style="position:absolute;top:12px;left:12px;z-index:20;background:#222;color:#fff;border-radius:50%;width:44px;height:44px;display:flex;align-items:center;justify-content:center;font-size:1.5rem;box-shadow:0 2px 8px #7c5cff44;border:none;cursor:pointer;">
  <span>üèÜ</span>
</button>
<div id="leaderboardModal" style="display:none;position:fixed;z-index:1001;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.25);backdrop-filter:blur(2.5px);justify-content:center;align-items:center;">
  <div style="background:#23243a;padding:24px 4vw 20px 4vw;border-radius:18px;box-shadow:0 8px 32px #000a;min-width:0;max-width:99vw;width:100%;max-width:400px;position:relative;display:flex;flex-direction:column;align-items:center;">
    <button id="closeLeaderboard" style="position:absolute;top:12px;right:12px;background:none;border:none;color:#fff;font-size:1.5rem;cursor:pointer;">‚úñÔ∏è</button>
    <h3 style="color:#a78bfa;margin-bottom:20px;font-size:1.22rem;font-weight:600;letter-spacing:0.5px;text-align:center;width:100%;">‡∏≠‡∏±‡∏ô‡∏î‡∏±‡∏ö‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î</h3>
    <table style="width:100%;border-collapse:collapse;font-size:1.08em;">
      <thead>
        <tr style="color:#a78bfa;text-align:center;"><th style="padding:7px 0;">#</th><th style="padding:7px 0;">‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô</th><th style="padding:7px 0;">‡πÄ‡∏ß‡∏•‡∏≤ (s)</th></tr>
      </thead>
      <tbody id="leaderboardModalBody"></tbody>
    </table>
  </div>
</div>
		</div>
		<script>
			const canvas = document.getElementById('gameCanvas');
			const ctx = canvas.getContext('2d');
			const scoreElement = document.getElementById('score');
			const gameOverElement = document.getElementById('gameOver');
			const finalScore = document.getElementById('finalScore');
			const gridSize = 30;
			const tileCount = canvas.width / gridSize;
			let snake, food, dx, dy, score, isGameRunning, lastUpdateTime;
			let frameInterval = 200;
			let gameStartTime = 0;
			let gameElapsed = 0;
			let isSnakeMoving = false;
			let pauseStart = 0;
			function resetGame() {
				snake = [{ x: Math.floor(tileCount / 2), y: Math.floor(tileCount / 2) }];
				dx = 0;
				dy = 0;
				score = 0;
				scoreElement.textContent = score;
				food = null;
				foods = [];
				let count = Math.max(3, window.foodCountSetting || 1);
				for (let i = 0; i < count; i++) {
					foods.push(randomFood());
				}
				isGameRunning = true;
				lastUpdateTime = 0;
				gameStartTime = 0;
				gameElapsed = 0;
				isSnakeMoving = false;
				document.getElementById('gameTime').textContent = '0.0s';
			}
			function randomFood() {
				let newFood;
				const scores = [10, 20, 30, 40, 50];
				do {
					newFood = {
						x: Math.floor(Math.random() * tileCount),
						y: Math.floor(Math.random() * tileCount),
						score: scores[Math.floor(Math.random() * scores.length)]
					};
				} while (snake.some(part => part.x === newFood.x && part.y === newFood.y) || (window.foods && window.foods.some(f => f.x === newFood.x && f.y === newFood.y)));
				return newFood;
			}
			function drawGrid() {
				ctx.save();
				ctx.strokeStyle = '#444';
				ctx.lineWidth = 1;
				for (let i = 1; i < tileCount; i++) {
					ctx.beginPath();
					ctx.moveTo(i * gridSize, 0);
					ctx.lineTo(i * gridSize, canvas.height);
					ctx.stroke();
					ctx.beginPath();
					ctx.moveTo(0, i * gridSize);
					ctx.lineTo(canvas.width, i * gridSize);
					ctx.stroke();
				}
				ctx.restore();
			}
			function drawSnake() {
				// Draw body
				if (snake.length > 1) {
					ctx.save();
					ctx.strokeStyle = '#7c5cff';
					ctx.lineCap = 'round';
					ctx.lineJoin = 'round';
					ctx.lineWidth = gridSize * 0.9;
					ctx.globalAlpha = 0.97;
					ctx.beginPath();
					ctx.moveTo(snake[0].x * gridSize + gridSize / 2, snake[0].y * gridSize + gridSize / 2);
					for (let i = 1; i < snake.length; i++) {
						const part = snake[i];
						const cx = part.x * gridSize + gridSize / 2;
						const cy = part.y * gridSize + gridSize / 2;
						// (‡∏•‡∏ö‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå‡πÅ‡∏ü‡∏•‡∏ä‡∏≠‡∏≠‡∏Å)
						ctx.lineTo(cx, cy);
					}
					ctx.stroke();
					ctx.globalAlpha = 1;
					ctx.restore();
				}
				if (snake.length > 0) {
					const cx = snake[0].x * gridSize + gridSize / 2;
					const cy = snake[0].y * gridSize + gridSize / 2;
					ctx.save();
					ctx.beginPath();
					ctx.arc(cx, cy, gridSize * 0.45, 0, Math.PI * 2);
					ctx.fillStyle = '#a78bfa';
					ctx.shadowColor = '#7c5cff';
					ctx.shadowBlur = 8;
					ctx.fill();
					ctx.shadowBlur = 0;
					ctx.beginPath();
					ctx.arc(cx - 5, cy - 3, 2, 0, Math.PI * 2);
					ctx.arc(cx + 5, cy - 3, 2, 0, Math.PI * 2);
					ctx.fillStyle = '#222';
					ctx.fill();
					ctx.beginPath();
					ctx.strokeStyle = '#222';
					ctx.lineWidth = 2;
					ctx.arc(cx, cy + 4, 6, 0.15 * Math.PI, 0.85 * Math.PI);
					ctx.stroke();
					ctx.restore();
				}
			}
			function drawFood() {
				ctx.save();
				for (const f of (window.foods || [food])) {
					const cx = f.x * gridSize + gridSize / 2;
					const cy = f.y * gridSize + gridSize / 2;
					// Color and gradient by score
					let grad, shadow, mainColor;
					if (f.score === 10) {
						grad = ctx.createRadialGradient(cx-6, cy-6, gridSize*0.1, cx, cy, gridSize*0.42);
						grad.addColorStop(0, '#fff1f2'); grad.addColorStop(0.4, '#fb7185'); grad.addColorStop(1, '#be123c');
						shadow = '#fb7185'; mainColor = '#fb7185';
					} else if (f.score === 20) {
						grad = ctx.createRadialGradient(cx-6, cy-6, gridSize*0.1, cx, cy, gridSize*0.42);
						grad.addColorStop(0, '#f0fff4'); grad.addColorStop(0.4, '#6ee7b7'); grad.addColorStop(1, '#059669');
						shadow = '#6ee7b7'; mainColor = '#34d399';
					} else if (f.score === 30) {
						grad = ctx.createRadialGradient(cx-6, cy-6, gridSize*0.1, cx, cy, gridSize*0.42);
						grad.addColorStop(0, '#fef9c3'); grad.addColorStop(0.4, '#fde047'); grad.addColorStop(1, '#f59e42');
						shadow = '#fde047'; mainColor = '#fde047';
					} else if (f.score === 40) {
						grad = ctx.createRadialGradient(cx-6, cy-6, gridSize*0.1, cx, cy, gridSize*0.42);
						grad.addColorStop(0, '#f3e8ff'); grad.addColorStop(0.4, '#a78bfa'); grad.addColorStop(1, '#7c3aed');
						shadow = '#a78bfa'; mainColor = '#a78bfa';
					} else {
						grad = ctx.createRadialGradient(cx-6, cy-6, gridSize*0.1, cx, cy, gridSize*0.42);
						grad.addColorStop(0, '#fef2f2'); grad.addColorStop(0.4, '#fca5a5'); grad.addColorStop(1, '#dc2626');
						shadow = '#fca5a5'; mainColor = '#dc2626';
					}
					// Fruit body
					ctx.save();
					ctx.beginPath();
					ctx.arc(cx, cy, gridSize * 0.42, 0, Math.PI * 2);
					ctx.fillStyle = grad;
					ctx.shadowColor = shadow;
					ctx.shadowBlur = 10;
					ctx.fill();
					ctx.shadowBlur = 0;
					// Outline
					ctx.beginPath();
					ctx.arc(cx, cy, gridSize * 0.42, 0, Math.PI * 2);
					ctx.lineWidth = 2.2;
					ctx.strokeStyle = 'rgba(80,0,40,0.18)';
					ctx.stroke();
					// Leaf
					ctx.save();
					ctx.translate(cx, cy - gridSize * 0.32);
					ctx.rotate(-0.3);
					ctx.beginPath();
					ctx.ellipse(0, 0, gridSize * 0.13, gridSize * 0.22, 0, 0, Math.PI * 2);
					ctx.fillStyle = '#6ee7b7';
					ctx.globalAlpha = 0.85;
					ctx.fill();
					ctx.restore();
					// Highlight
					ctx.beginPath();
					ctx.ellipse(cx - gridSize * 0.13, cy - gridSize * 0.13, gridSize * 0.09, gridSize * 0.18, -0.7, 0, Math.PI * 2);
					ctx.fillStyle = 'rgba(255,255,255,0.22)';
					ctx.fill();
					ctx.restore();
				}
				ctx.restore();
			}
			function moveSnake() {
				if (!isSnakeMoving && (dx !== 0 || dy !== 0)) {
					isSnakeMoving = true;
					gameStartTime = Date.now();
				}
				if (isSnakeMoving) {
					// ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏î‡∏¥‡∏ô‡∏à‡∏£‡∏¥‡∏á
					gameElapsed += (Date.now() - gameStartTime) / 1000;
					gameStartTime = Date.now();
				}
				const head = { x: snake[0].x + dx, y: snake[0].y + dy };
				snake.unshift(head);
				let ate = false;
				for (let i = 0; i < foods.length; i++) {
					if (head.x === foods[i].x && head.y === foods[i].y) {
						const fruitScore = foods[i].score || 10;
						score += fruitScore;
						scoreElement.textContent = score;
						foods[i] = randomFood();
						ate = true;
						break;
					}
				}
				if (!ate) {
					snake.pop();
				}
			}
			function checkCollision() {
				const head = snake[0];
				if (
					head.x < 0 ||
					head.y < 0 ||
					head.x >= tileCount ||
					head.y >= tileCount ||
					snake.slice(1).some(part => part.x === head.x && part.y === head.y)
				) {
					return true;
				}
				return false;
			}
			function drawGame() {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				drawGrid();
				drawFood();
				drawSnake();
			}
			function updateGameTime() {
    if (!isGameRunning) return;
    let t = gameElapsed;
    if (isSnakeMoving && !isPaused && gameStartTime) {
        t += (Date.now() - gameStartTime) / 1000;
    }
    document.getElementById('gameTime').textContent = t.toFixed(1) + 's';
}
			function gameLoop(timestamp) {
				if (!isGameRunning) return;
				if (isPaused) {
					updateGameTime();
					requestAnimationFrame(gameLoop);
					return;
				}
				const delta = timestamp - lastUpdateTime;
				if (delta > frameInterval) {
					moveSnake();
					if (checkCollision()) {
						endGame();
						return;
					}
					lastUpdateTime = timestamp;
				}
				updateGameTime();
				drawGame();
				requestAnimationFrame(gameLoop);
			}
			function startGame() {
				resetGame();
				gameOverElement.style.display = 'none';
				isSnakeMoving = false;
				requestAnimationFrame(gameLoop);
			}
			function saveToLeaderboard(score, time) {
    let data = JSON.parse(localStorage.getItem('snakeLeaderboard') || '[]');
    data.push({score, time});
    // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏°‡∏≤‡∏Å‡πÑ‡∏õ‡∏ô‡πâ‡∏≠‡∏¢ ‡∏ñ‡πâ‡∏≤‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡πà‡∏≠‡∏ô
    data.sort((a, b) => b.score - a.score || a.time - b.time);
    data = data.slice(0, 10); // top 10
    localStorage.setItem('snakeLeaderboard', JSON.stringify(data));
}
function renderLeaderboard() {
    let data = JSON.parse(localStorage.getItem('snakeLeaderboard') || '[]');
    const tbody = document.getElementById('leaderboardBody');
    tbody.innerHTML = '';
    data.forEach((row, i) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td style='text-align:center;'>${i+1}</td><td style='text-align:center;'>${row.score}</td><td style='text-align:center;'>${row.time.toFixed(1)}</td>`;
        tbody.appendChild(tr);
    });
    document.getElementById('leaderboard').style.display = data.length ? '' : 'none';
}
function renderLeaderboardUI() {
    let data = JSON.parse(localStorage.getItem('snakeLeaderboard') || '[]');
    const tbody = document.getElementById('leaderboardUiBody');
    tbody.innerHTML = '';
    data.forEach((row, i) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${i+1}</td><td>${row.score}</td><td>${row.time.toFixed(1)}</td>`;
        tbody.appendChild(tr);
    });
    document.getElementById('leaderboard-ui').style.display = data.length ? '' : 'none';
}
function renderLeaderboardModal() {
    let data = JSON.parse(localStorage.getItem('snakeLeaderboard') || '[]');
    const tbody = document.getElementById('leaderboardModalBody');
    tbody.innerHTML = '';
    data.forEach((row, i) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td style='text-align:center;'>${i+1}</td><td style='text-align:center;'>${row.score}</td><td style='text-align:center;'>${row.time.toFixed(1)}</td>`;
        tbody.appendChild(tr);
    });
}
			function endGame() {
				isGameRunning = false;
				finalScore.textContent = score;
				// ‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏ß‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏î‡∏¥‡∏ô‡∏à‡∏£‡∏¥‡∏á
				let t = gameElapsed;
				if (isSnakeMoving && !isPaused && gameStartTime) {
					t += (Date.now() - gameStartTime) / 1000;
				}
				document.getElementById('finalTime').textContent = t.toFixed(1);
				saveToLeaderboard(score, t);
				renderLeaderboard();
				renderLeaderboardUI();
				gameOverElement.style.display = 'block';
			}
			let isPaused = false;
			function setPause(paused) {
				isPaused = paused;
				const pauseBtn = document.getElementById('pauseBtn');
				if (pauseBtn) {
					pauseBtn.textContent = isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
				}
				if (isPaused) {
					// ‡∏Å‡∏î‡∏´‡∏¢‡∏∏‡∏î: ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏´‡∏¢‡∏∏‡∏î
					pauseStart = Date.now();
				} else {
					// ‡∏Å‡∏î‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏î‡∏¥‡∏ô‡∏à‡∏£‡∏¥‡∏á
					if (pauseStart) {
						gameStartTime += Date.now() - pauseStart;
						pauseStart = 0;
					}
				}
			}
			document.addEventListener('DOMContentLoaded', () => {
				const pauseBtn = document.getElementById('pauseBtn');
				if (pauseBtn) {
					pauseBtn.addEventListener('click', () => {
						setPause(!isPaused);
						if (!isPaused) {
							lastUpdateTime = performance.now();
							requestAnimationFrame(gameLoop);
						}
					});
				}
			});
			document.addEventListener('keydown', e => {
    // Prevent arrow keys from scrolling the page, but allow mouse wheel
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
        e.preventDefault();
    }
    if (e.key === 'ArrowUp' && dy !== 1) { setDirection(0, -1); }
    if (e.key === 'ArrowDown' && dy !== -1) { setDirection(0, 1); }
    if (e.key === 'ArrowLeft' && dx !== 1) { setDirection(-1, 0); }
    if (e.key === 'ArrowRight' && dx !== -1) { setDirection(1, 0); }
});
			document.getElementById('up').addEventListener('touchstart', (e) => { e.preventDefault(); if (dy !== 1) { setDirection(0, -1); } });
			document.getElementById('down').addEventListener('touchstart', (e) => { e.preventDefault(); if (dy !== -1) { setDirection(0, 1); } });
			document.getElementById('left').addEventListener('touchstart', (e) => { e.preventDefault(); if (dx !== 1) { setDirection(-1, 0); } });
			document.getElementById('right').addEventListener('touchstart', (e) => { e.preventDefault(); if (dx !== -1) { setDirection(1, 0); } });
			document.addEventListener('DOMContentLoaded', () => {
				const settingsBtn = document.getElementById('settingsBtn');
				const settingsModal = document.getElementById('settingsModal');
				const closeSettings = document.getElementById('closeSettings');
				const speedInput = document.getElementById('speedInput');
				const foodInput = document.getElementById('foodInput');
				settingsBtn.addEventListener('click', () => {
					settingsModal.style.display = 'flex';
					speedInput.value = frameInterval;
					foodInput.value = window.foodCountSetting || 1;
				});
				closeSettings.addEventListener('click', () => {
					settingsModal.style.display = 'none';
				});
				settingsModal.addEventListener('click', (e) => {
					if (e.target === settingsModal) settingsModal.style.display = 'none';
				});
				speedInput.addEventListener('input', () => {
					let v = parseInt(speedInput.value);
					if (speedInput.value === '') {
						frameInterval = 200;
						return;
					}
					if (isNaN(v) || v <= 0) v = 1;
					speedInput.value = v;
					frameInterval = v;
				});
				foodInput.addEventListener('input', () => {
					let v = parseInt(foodInput.value);
					if (foodInput.value === '') {
						window.foodCountSetting = 1;
						return;
					}
					if (isNaN(v) || v <= 0) v = 1;
					foodInput.value = v;
					window.foodCountSetting = v;
				});
				window.foodCountSetting = 1;
				frameInterval = parseInt(speedInput.value) || 200;
			});
			function setDirection(newDx, newDy) {
    dx = newDx;
    dy = newDy;
}
			document.addEventListener('DOMContentLoaded', () => {
    const leaderboardBtn = document.getElementById('leaderboardBtn');
    const leaderboardModal = document.getElementById('leaderboardModal');
    const closeLeaderboard = document.getElementById('closeLeaderboard');
    leaderboardBtn.addEventListener('click', () => {
        renderLeaderboardModal();
        leaderboardModal.style.display = 'flex';
    });
    closeLeaderboard.addEventListener('click', () => {
        leaderboardModal.style.display = 'none';
    });
    leaderboardModal.addEventListener('click', (e) => {
        if (e.target === leaderboardModal) leaderboardModal.style.display = 'none';
    });
});
			window.addEventListener('DOMContentLoaded', renderLeaderboard);
			window.addEventListener('DOMContentLoaded', renderLeaderboardUI);
			startGame();
		</script>
	</body>
</html>
