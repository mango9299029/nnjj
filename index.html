<!doctype html>
<html lang="th">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>‡πÄ‡∏Å‡∏°‡∏á‡∏π test2</title>

    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;500;700&display=swap" rel="stylesheet" />

    <style>
      :root {
        --bg-dark: #121217;
        --panel-dark: #1e1f29;
        --accent: #7c5cff;
        --text-light: #e1e2e7;
        --text-muted: #888ba7;
        --btn-bg: #2a2c3d;
        --btn-hover: #3b3f58;
        --shadow: rgba(124, 92, 255, 0.4);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: 'Poppins', sans-serif;
        -webkit-tap-highlight-color: transparent;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background: var(--bg-dark);
        color: var(--text-light);
      }

      .game-container {
        text-align: center;
        background: var(--panel-dark);
        border-radius: 20px;
        padding: 25px 30px;
        box-shadow: 0 10px 30px var(--shadow);
        position: relative;
      }

      .score {
        font-size: 22px;
        margin-bottom: 8px;
        color: var(--accent);
        font-weight: 700;
      }

      canvas {
        border: 3px solid var(--accent);
        border-radius: 10px;
        background: #2a2c3d;
        width: 100%;
        max-width: 400px;
        height: auto;
      }

      .controls {
        margin-top: 24px;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        gap: 12px;
        background: #23243a;
        border-radius: 14px;
        padding: 16px 10px 10px 10px;
        box-shadow: 0 2px 8px var(--shadow);
      }

      .controls label {
        color: var(--text-light);
        font-size: 1.05rem;
        margin-bottom: 0;
        display: flex;
        align-items: center;
        gap: 6px;
        background: #23243a;
        border-radius: 8px;
        padding: 4px 8px;
        box-shadow: 0 1px 4px #0002;
      }

      .controls .input-group {
        display: flex;
        align-items: center;
        gap: 2px;
        background: #181828;
        border-radius: 6px;
        padding: 2px 4px;
      }

      .controls input[type="range"] {
        accent-color: var(--accent);
        width: 90px;
        margin: 0 6px;
      }

      .controls input[type="number"] {
        width: 54px;
        border-radius: 6px;
        border: 1px solid #444;
        background: #181828;
        color: var(--text-light);
        padding: 2px 4px;
        font-size: 1rem;
        text-align: center;
        margin: 0 2px;
      }

      .controls .step-btn {
        background: var(--btn-bg);
        color: var(--accent);
        border: none;
        border-radius: 4px;
        width: 28px;
        height: 28px;
        font-size: 1.2rem;
        cursor: pointer;
        transition: background 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .controls .step-btn:hover {
        background: var(--btn-hover);
      }

      .controls button {
        margin: 0 4px;
        min-width: 44px;
        min-height: 44px;
        font-size: 1.1rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      button {
        background: var(--btn-bg);
        color: var(--text-light);
        border: none;
        padding: 18px 24px;
        border-radius: 14px;
        font-size: 1.4rem;
        font-weight: 600;
        cursor: pointer;
        margin: 8px;
        transition:
          background 0.3s ease,
          box-shadow 0.3s ease,
          transform 0.15s ease;
        box-shadow: 0 4px 8px var(--shadow);
      }

      button:hover {
        background: var(--btn-hover);
        box-shadow: 0 6px 20px var(--shadow);
      }
      
      button:active {
        transform: scale(0.96);
      }

      .dpad {
        display: grid;
        grid-template-columns: 60px 60px 60px;
        grid-template-rows: 60px 60px 60px;
        justify-content: center;
        gap: 6px;
        margin-top: 16px;
      }

      .dpad button {
        width: 60px;
        height: 60px;
        font-size: 24px;
        border-radius: 12px;
        padding: 0; /* ‡∏•‡∏ö padding ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡∏°‡∏≤‡∏≠‡∏≠‡∏Å */
      }

      .dpad .empty {
        visibility: hidden;
      }

      .game-over {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.85);
        padding: 30px;
        border-radius: 15px;
        text-align: center;
      }

      @media (max-width: 480px) {
        .dpad button {
          width: 50px;
          height: 50px;
          font-size: 20px;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <div class="score">‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: <span id="score">0</span></div>
      <canvas id="gameCanvas" width="390" height="390"></canvas>

      <div class="controls">
        <label>
          <span>‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß</span>
          <div class="input-group">
            <button class="step-btn" id="speedDown" tabindex="-1">-</button>
            <input id="speedInput" type="number" min="50" max="500" value="200" step="10">
            <button class="step-btn" id="speedUp" tabindex="-1">+</button>
          </div>
          <span id="speedValue">ms</span>
        </label>
        <label>
          <span>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ú‡∏•‡πÑ‡∏°‡πâ</span>
          <div class="input-group">
            <button class="step-btn" id="foodDown" tabindex="-1">-</button>
            <input id="foodInput" type="number" min="1" max="10" value="1">
            <button class="step-btn" id="foodUp" tabindex="-1">+</button>
          </div>
        </label>
        <button id="pauseBtn" title="‡∏´‡∏¢‡∏∏‡∏î/‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠" style="background:var(--accent);color:#fff;">
          <span id="pauseIcon">‚è∏Ô∏è</span>
        </button>
        <button onclick="startGame()" title="‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà">üîÑ</button>
      </div>

      <div class="dpad">
        <div class="empty"></div>
        <button id="up">‚¨ÜÔ∏è</button>
        <div class="empty"></div>
        <button id="left">‚¨ÖÔ∏è</button>
        <div class="empty"></div>
        <button id="right">‚û°Ô∏è</button>
        <div class="empty"></div>
        <button id="down">‚¨áÔ∏è</button>
        <div class="empty"></div>
      </div>

      <div class="game-over" id="gameOver">
        <h2>‡∏Å‡∏≤‡∏Åüí©</h2>
        <p>‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì: <span id="finalScore">0</span></p>
        <button onclick="startGame()">‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</button>
      </div>
    </div>

    <script>
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const scoreElement = document.getElementById('score');
      const gameOverElement = document.getElementById('gameOver');
      const finalScore = document.getElementById('finalScore');

  const gridSize = 30;
  const tileCount = canvas.width / gridSize;
  let snake, foods, dx, dy, score, isGameRunning, lastUpdateTime;
  let moveTimer = 0;
  let moveInterval = 200; // ms ‡∏ï‡πà‡∏≠ 1 ‡∏ä‡πà‡∏≠‡∏á (‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö 60fps)
  let animProgress = 1; // 0-1
  let foodCount = 1;
  let isPaused = false;
      // --- UI: ‡∏õ‡∏∏‡πà‡∏°‡∏´‡∏¢‡∏∏‡∏î/‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠ ---
      function setPause(paused) {
        isPaused = paused;
        const pauseIcon = document.getElementById('pauseIcon');
        if (isPaused) {
          pauseIcon.textContent = '‚ñ∂Ô∏è';
        } else {
          pauseIcon.textContent = '‚è∏Ô∏è';
        }
      }

      // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà
      function resetGame() {
        snake = [{ x: Math.floor(tileCount / 2), y: Math.floor(tileCount / 2) }];
        dx = 0;
        dy = 0;
        score = 0;
        scoreElement.textContent = score;
        foods = [];
        for (let i = 0; i < foodCount; i++) {
          foods.push(randomFood());
        }
        isGameRunning = true;
        lastUpdateTime = 0;
        moveTimer = 0;
        animProgress = 1;
      }

      // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏∏‡πà‡∏°‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ú‡∏•‡πÑ‡∏°‡πâ‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏•‡∏∞‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡∏ö‡∏Å‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡∏á‡∏π
      function randomFood() {
        let newFood;
        do {
          newFood = {
            x: Math.floor(Math.random() * tileCount),
            y: Math.floor(Math.random() * tileCount)
          };
        } while (
          snake.some(part => part.x === newFood.x && part.y === newFood.y) ||
          foods?.some(f => f.x === newFood.x && f.y === newFood.y)
        );
        return newFood;
      }

      // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ß‡∏≤‡∏î‡∏á‡∏π (‡∏•‡∏≥‡∏ï‡∏±‡∏ß‡πÑ‡∏£‡πâ‡∏£‡∏≠‡∏¢‡∏ï‡πà‡∏≠‡πÅ‡∏ö‡∏ö‡∏ó‡∏£‡∏á‡∏Å‡∏£‡∏∞‡∏ö‡∏≠‡∏Å)
      function drawSnake() {
        const bodyWidth = gridSize * 0.92;
        // ‡∏ß‡∏≤‡∏î‡∏•‡∏≥‡∏ï‡∏±‡∏ß‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡πÇ‡∏Ñ‡πâ‡∏á‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á
        if (snake.length > 1) {
          ctx.save();
          ctx.strokeStyle = '#7c5cff';
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.lineWidth = bodyWidth;
          ctx.globalAlpha = 0.97;
          ctx.beginPath();
          for (let i = 0; i < snake.length; i++) {
            const part = snake[i];
            const cx = part.x * gridSize + gridSize / 2;
            const cy = part.y * gridSize + gridSize / 2;
            if (i === 0) {
              ctx.moveTo(cx, cy);
            } else {
              ctx.lineTo(cx, cy);
            }
          }
          ctx.stroke();
          ctx.globalAlpha = 1;
          ctx.restore();
        }
        // ‡∏ß‡∏≤‡∏î‡∏´‡∏±‡∏ß‡∏á‡∏π‡∏ó‡∏±‡∏ö (‡∏Å‡∏•‡∏°+‡∏ï‡∏≤+‡∏¢‡∏¥‡πâ‡∏°)
        if (snake.length > 0) {
          const head = snake[0];
          const cx = head.x * gridSize + gridSize / 2;
          const cy = head.y * gridSize + gridSize / 2;
          ctx.save();
          ctx.beginPath();
          ctx.arc(cx, cy, gridSize * 0.5, 0, Math.PI * 2);
          ctx.fillStyle = '#a78bfa';
          ctx.shadowColor = '#7c5cff';
          ctx.shadowBlur = 8;
          ctx.fill();
          ctx.shadowBlur = 0;
          // ‡∏ï‡∏≤
          ctx.beginPath();
          ctx.arc(cx - 5, cy - 3, 2, 0, Math.PI * 2);
          ctx.arc(cx + 5, cy - 3, 2, 0, Math.PI * 2);
          ctx.fillStyle = '#222';
          ctx.fill();
          // ‡∏£‡∏≠‡∏¢‡∏¢‡∏¥‡πâ‡∏°
          ctx.beginPath();
          ctx.strokeStyle = '#222';
          ctx.lineWidth = 2;
          ctx.arc(cx, cy + 4, 6, 0.15 * Math.PI, 0.85 * Math.PI);
          ctx.stroke();
          ctx.restore();
        }
      }

      // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ß‡∏≤‡∏î‡∏ú‡∏•‡πÑ‡∏°‡πâ (‡∏Å‡∏•‡∏°‡πÅ‡∏î‡∏á+‡πÉ‡∏ö‡πÑ‡∏°‡πâ)
      function drawFood() {
        const size = gridSize * 0.9;
        for (const food of foods) {
          const cx = food.x * gridSize + gridSize / 2;
          const cy = food.y * gridSize + gridSize / 2;
          ctx.save();
          ctx.beginPath();
          ctx.arc(cx, cy, size / 2, 0, Math.PI * 2);
          const grad = ctx.createRadialGradient(cx, cy, size/6, cx, cy, size/2);
          grad.addColorStop(0, '#fff1f2');
          grad.addColorStop(0.5, '#fb7185');
          grad.addColorStop(1, '#be123c');
          ctx.fillStyle = grad;
          ctx.shadowColor = '#fb7185';
          ctx.shadowBlur = 8;
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.beginPath();
          ctx.ellipse(cx - 4, cy - size/2 + 6, 6, 2.5, -0.5, 0, Math.PI * 2);
          ctx.fillStyle = '#22c55e';
          ctx.fill();
          ctx.restore();
        }
      }

      // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏á‡∏π (‡∏ó‡∏µ‡∏•‡∏∞‡∏ä‡πà‡∏≠‡∏á)
      function moveSnake() {
        if (dx === 0 && dy === 0) return;
        const head = { x: snake[0].x + dx, y: snake[0].y + dy };
        snake.unshift(head);
        let ate = false;
        for (let i = 0; i < foods.length; i++) {
          if (head.x === foods[i].x && head.y === foods[i].y) {
            score += 1;
            scoreElement.textContent = score;
            foods[i] = randomFood();
            ate = true;
            break;
          }
        }
        if (!ate) {
          snake.pop();
        }
      }
      // --- UI: ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÅ‡∏•‡∏∞‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ú‡∏•‡πÑ‡∏°‡πâ ---
      document.addEventListener('DOMContentLoaded', () => {
        const speedInput = document.getElementById('speedInput');
        const speedValue = document.getElementById('speedValue');
        const foodInput = document.getElementById('foodInput');
        speedInput.addEventListener('input', () => {
          moveInterval = parseInt(speedInput.value);
          speedValue.textContent = speedInput.value;
        });
        foodInput.addEventListener('input', () => {
          let val = parseInt(foodInput.value);
          if (isNaN(val) || val < 1) val = 1;
          if (val > 10) val = 10;
          foodCount = val;
        });
        // sync initial value
        speedValue.textContent = speedInput.value;
        foodCount = parseInt(foodInput.value);
      });

      // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ä‡πà‡∏≠‡∏á (interpolate)
      function getInterpolatedSnake(progress) {
        // progress: 0 (old pos) -> 1 (new pos)
        const interp = [];
        for (let i = 0; i < snake.length - 1; i++) {
          const a = snake[i];
          const b = snake[i + 1];
          interp.push({
            x: a.x * progress + b.x * (1 - progress),
            y: a.y * progress + b.y * (1 - progress)
          });
        }
        interp.push(snake[snake.length - 1]);
        return interp;
      }

      // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ä‡∏ô
      function checkCollision() {
        const head = snake[0];
        if (
          head.x < 0 ||
          head.y < 0 ||
          head.x >= tileCount ||
          head.y >= tileCount ||
          snake.slice(1).some(part => part.x === head.x && part.y === head.y)
        ) {
          return true;
        }
        return false;
      }

      // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ß‡∏≤‡∏î‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏Å‡∏°
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ß‡∏≤‡∏î‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á
        function drawGrid() {
          ctx.save();
          ctx.strokeStyle = '#444';
          ctx.lineWidth = 1;
          for (let i = 1; i < tileCount; i++) {
            // ‡πÄ‡∏™‡πâ‡∏ô‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á
            ctx.beginPath();
            ctx.moveTo(i * gridSize, 0);
            ctx.lineTo(i * gridSize, canvas.height);
            ctx.stroke();
            // ‡πÄ‡∏™‡πâ‡∏ô‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô
            ctx.beginPath();
            ctx.moveTo(0, i * gridSize);
            ctx.lineTo(canvas.width, i * gridSize);
            ctx.stroke();
          }
          ctx.restore();
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ß‡∏≤‡∏î‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏Å‡∏° (‡∏≠‡∏ô‡∏¥‡πÄ‡∏°‡∏ä‡∏±‡∏ô‡∏•‡∏∑‡πà‡∏ô‡πÑ‡∏´‡∏•)
        function drawGame(progress) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawGrid();
          if (checkCollision()) {
            endGame();
            return;
          }
          drawFood();
          // ‡∏ß‡∏≤‡∏î‡∏á‡∏π‡∏î‡πâ‡∏ß‡∏¢‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á interpolate
          const interpSnake = getInterpolatedSnake(progress);
          drawSnake(interpSnake);
        }

      // ‡∏•‡∏π‡∏õ‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡∏° (‡∏≠‡∏ô‡∏¥‡πÄ‡∏°‡∏ä‡∏±‡∏ô‡∏•‡∏∑‡πà‡∏ô‡πÑ‡∏´‡∏•)
      function gameLoop(timestamp) {
        if (!isGameRunning) return;
        if (isPaused) {
          requestAnimationFrame(gameLoop);
          return;
        }
        if (!lastUpdateTime) lastUpdateTime = timestamp;
        let delta = timestamp - lastUpdateTime;
        lastUpdateTime = timestamp;
        moveTimer += delta;
        let moved = false;
        while (moveTimer >= moveInterval) {
          moveSnake();
          moveTimer -= moveInterval;
          moved = true;
        }
        animProgress = moveTimer / moveInterval;
        if (moved) animProgress = 0;
        drawGame(animProgress);
        requestAnimationFrame(gameLoop);
      }
      // --- UI: ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÅ‡∏•‡∏∞‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ú‡∏•‡πÑ‡∏°‡πâ + ‡∏õ‡∏∏‡πà‡∏°‡∏´‡∏¢‡∏∏‡∏î ---
      document.addEventListener('DOMContentLoaded', () => {
        const speedInput = document.getElementById('speedInput');
        const speedValue = document.getElementById('speedValue');
        const foodInput = document.getElementById('foodInput');
        const pauseBtn = document.getElementById('pauseBtn');
        const speedDown = document.getElementById('speedDown');
        const speedUp = document.getElementById('speedUp');
        const foodDown = document.getElementById('foodDown');
        const foodUp = document.getElementById('foodUp');

        // ‡∏õ‡∏£‡∏±‡∏ö speed
        function updateSpeed(val) {
          let v = parseInt(val);
          if (isNaN(v) || v < 50) v = 50;
          if (v > 500) v = 500;
          moveInterval = v;
          speedInput.value = v;
          speedValue.textContent = v + ' ms';
        }
        speedInput.addEventListener('input', e => updateSpeed(e.target.value));
        speedDown.addEventListener('click', () => updateSpeed(parseInt(speedInput.value) - 10));
        speedUp.addEventListener('click', () => updateSpeed(parseInt(speedInput.value) + 10));

        // ‡∏õ‡∏£‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ú‡∏•‡πÑ‡∏°‡πâ
        function updateFood(val) {
          let v = parseInt(val);
          if (isNaN(v) || v < 1) v = 1;
          if (v > 10) v = 10;
          foodCount = v;
          foodInput.value = v;
        }
        foodInput.addEventListener('input', e => updateFood(e.target.value));
        foodDown.addEventListener('click', () => updateFood(parseInt(foodInput.value) - 1));
        foodUp.addEventListener('click', () => updateFood(parseInt(foodInput.value) + 1));

        // sync initial value
        updateSpeed(speedInput.value);
        updateFood(foodInput.value);

        // ‡∏õ‡∏∏‡πà‡∏°‡∏´‡∏¢‡∏∏‡∏î/‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠ (resume ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠‡∏õ‡∏Å‡∏ï‡∏¥ ‡πÑ‡∏°‡πà‡∏à‡∏ö‡πÄ‡∏Å‡∏°)
        pauseBtn.addEventListener('click', () => {
          if (!isPaused) {
            setPause(true);
          } else {
            setPause(false);
            // ‡∏õ‡∏£‡∏±‡∏ö lastUpdateTime ‡πÉ‡∏´‡πâ‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏Ç‡∏¢‡∏±‡∏ö‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏´‡∏•‡∏±‡∏á resume
            lastUpdateTime = performance.now();
          }
        });
      });

      // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°
      function startGame() {
        resetGame();
        gameOverElement.style.display = 'none';
        requestAnimationFrame(gameLoop);
      }

      // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏à‡∏ö‡πÄ‡∏Å‡∏°
      function endGame() {
        isGameRunning = false;
        finalScore.textContent = score;
        gameOverElement.style.display = 'block';
      }

      // ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡∏µ‡∏¢‡πå‡∏ö‡∏≠‡∏£‡πå‡∏î
      document.addEventListener('keydown', e => {
        if (e.key === 'ArrowUp' && dy !== 1) { dx = 0; dy = -1; }
        if (e.key === 'ArrowDown' && dy !== -1) { dx = 0; dy = 1; }
        if (e.key === 'ArrowLeft' && dx !== 1) { dx = -1; dy = 0; }
        if (e.key === 'ArrowRight' && dx !== -1) { dx = 1; dy = 0; }
      });

      // ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏±‡∏°‡∏ú‡∏±‡∏™
      document.getElementById('up').addEventListener('touchstart', (e) => { e.preventDefault(); if (dy !== 1) { dx = 0; dy = -1; } });
      document.getElementById('down').addEventListener('touchstart', (e) => { e.preventDefault(); if (dy !== -1) { dx = 0; dy = 1; } });
      document.getElementById('left').addEventListener('touchstart', (e) => { e.preventDefault(); if (dx !== 1) { dx = -1; dy = 0; } });
      document.getElementById('right').addEventListener('touchstart', (e) => { e.preventDefault(); if (dx !== -1) { dx = 1; dy = 0; } });

      startGame();
        // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£ scroll ‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡∏µ‡∏¢‡πå‡∏ö‡∏≠‡∏£‡πå‡∏î (arrow, space, page)
        window.addEventListener('keydown', function(e) {
          // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô scroll ‡∏î‡πâ‡∏ß‡∏¢‡∏õ‡∏∏‡πà‡∏°‡∏•‡∏π‡∏Å‡∏®‡∏£, space, pageup/down, home/end
          const keys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Spacebar', 'PageUp', 'PageDown', 'Home', 'End'];
          if (keys.includes(e.key)) {
            e.preventDefault();
          }
        }, { passive: false });

        // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£ scroll ‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏±‡∏°‡∏ú‡∏±‡∏™‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠ (touchmove)
        window.addEventListener('touchmove', function(e) {
          e.preventDefault();
        }, { passive: false });
    </script>
  </body>
</html>
